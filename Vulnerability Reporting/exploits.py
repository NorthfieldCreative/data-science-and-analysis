################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function searches all discovered CVEs for      ##              ####
####            ##      matches in Offsec's exploitDB, reporting on the     ##              ####
####            ##      results.                                            ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
from tkinter import CENTER, N
from pyExploitDb import PyExploitDb

def exploitsearch(month,year,sqladbconn):

    #Creating a list to store found exploits in
    availableexploits=[]
    query="SELECT * FROM "+month.lower()+"_"+str(year)
    monthtocount=pd.read_sql(query, sqladbconn)
    #isolating the CVE column for processing
    tempcvelist = monthtocount['CVE']
    #converting the created series to a dataframe to be cleaned up
    cvelist=pd.DataFrame(tempcvelist, columns=['CVE'])
    #dropping rows with no CVE
    cvelist=cvelist.dropna()
    #dropping duplicate CVE entries
    cvelist=cvelist.drop_duplicates()
    #converting to a list for easy iteration later on
    cvelist=cvelist['CVE'].tolist()
    '''
    try:
        #loading in the scan report 
        xl=pd.ExcelFile('Shure_External_September_2022.xlsx')
        restring='.*September.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        monthtocount = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
        #isolating the CVE column for processing
        tempcvelist = monthtocount['CVE']
        #converting the created series to a dataframe to be cleaned up
        cvelist=pd.DataFrame(tempcvelist, columns=['CVE'])
        #dropping rows with no CVE
        cvelist=cvelist.dropna()
        #dropping duplicate CVE entries
        cvelist=cvelist.drop_duplicates()
        #converting to a list for easy iteration later on
        cvelist=cvelist['CVE'].tolist()
    except:
        print("While attempting to calculate top 10 vulnerable hosts for ", convertedmonth,", we expected to find ", inputmonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
        '''

    gcolumns=list(monthtocount)
    exploitablemachines=pd.DataFrame(columns=gcolumns)

    #iterating through each discovered CVE to search for exploits
    for cve in cvelist:

        print("\n\n\n")
        pEdb = PyExploitDb() 
        pEdb.debug = False 
        pEdb.openFile() 
        results = pEdb.searchCve(cve) 

        if not results:
            print("No exploit found")
        else:
            #add the found exploit to a list
            availableexploits.append(cve)
            #when an exploit is found, adding the full row from the scan report for context
            df1=monthtocount[monthtocount["CVE"].str.contains(cve, na=False)]
            #Combining this iteration's results with all results
            exploitablemachines=pd.concat([exploitablemachines, df1])
            availableexploits.append(cve)

    availableexploits=list(dict.fromkeys(availableexploits))
    print("\n\n\n")
    print("For "+month+", these CVEs were discovered in our environment with an available exploit:")

    print(availableexploits)
    print("\nThe below table is a preview of the complete discovery of machines with easily available exploits.")
    print("exploitablemachines.csv has been saved to the current working directory for review\n")
    exploitablemachines.to_csv(r'exploitablemachines.csv', index = False)
    return exploitablemachines

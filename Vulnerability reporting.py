from asyncio import protocols
from calendar import month
from operator import index
from tkinter import CENTER, N
from turtle import forward
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
import os.path
from datetime import datetime
from pptx import Presentation
import subprocess, os, platform
import re
from unittest import result
import mysql.connector
import sqlalchemy
from pyExploitDb import PyExploitDb
import getmonth
#Variable to capture the current numerical month
rawmonth=datetime.now().month
year=datetime.now().year
#variable to be used later to hold the month in string form
currentmonth="null"

# Setting a standard size for charts
plt.rcParams['figure.figsize'] = [18, 7]




##########################################################
##                                                      ##
##      This function translates a numerical month      ##
##      into a string                                   ##
##                                                      ##
##########################################################
'''
def getmonth(number):
    if number == 1:
        currentmonth="January"
    elif number==2:
        currentmonth="February"
    elif number==3:
        currentmonth="March"
    elif number==4:
        currentmonth="April"
    elif number==5:
        currentmonth="May"
    elif number==6:
        currentmonth="June"
    elif number==7:
        currentmonth="July"
    elif number==8:
        currentmonth="August"
    elif number==9:
        currentmonth="September"
    elif number==10:
        currentmonth="October"
    elif number==11:
        currentmonth="November"
    elif number==12:
        currentmonth="December"
    return currentmonth
'''


#######################################
###     database connection         ###
#######################################
dbuser="exiged"
dbpass="PROduct$123CHEmical$123"
dbip="192.168.100.10"
dbname="testdb"
#dbpass=input('Password:')
mydb = mysql.connector.connect(
  host=dbip,
  user=dbuser,
  password=dbpass,
  database=dbname
)

mycursor = mydb.cursor()
sqladbconn = sqlalchemy.create_engine('mysql+mysqlconnector://{0}:{1}@{2}/{3}'.
                                               format(dbuser, dbpass, 
                                                      dbip, dbname))


#Variables to check if data exists in the DB
currenttable=getmonth.getmonth(rawmonth)+"_"+str(year)
lastmonthstable=getmonth.getmonth(rawmonth-1)+"_"+str(year)


mycursor.execute("SHOW TABLES")

###############################################
### checking if a table already exists      ###
### for the current month in the DB         ###
###############################################
for x in mycursor:
    if not currenttable.lower() in x[0]:
        currentmonthindb=False
        
    else:
        currentmonthindb=True
        break


#'''
###########################################################################
### If current data not found, asking if it is available for ingestion  ###
###########################################################################
if currentmonthindb==False:
    print("Data for the current month was not found in the database")
    newdatatoprocess=input("Is this month's scan available for ingestion? (y/n)")
    while newdatatoprocess != "y" and newdatatoprocess != "n":
        newdatatoprocess=input("Please input exactly y or n. Is this month's scan available for ingestion? (y/n)")
    if newdatatoprocess=="y":
        print("new data confirmed available for processing")
        datatoprocess=input("drag and drop scan data here to process")
        parsingfileinput=re.findall("c:.*\.xlsx", datatoprocess)
        if not parsingfileinput:
            print("xlsx file not found, please start over and try again")
        else:
            print("Standby, ingesting the below file:")
            print(parsingfileinput[0])
    else:
        print("new data confirmed not available.")
        continuewithold=input("Would you like to proceed with older data? (y/n): ")
        while continuewithold != "y" and continuewithold !="n":
            continuewithold=input("Please input exactly y or n. Would you like to proceed with older data? (y/n: ")
        if continuewithold == "n":
            print("QUITTING")
            exit()


#'''










################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      A function to return the top 10 vulnerable IPs      ##              ####
####            ##      by count of vulnerabilities for the current month.  ##              ####
####            ##      This function will return results in a stacked bar  ##              ####
####            ##      chart                                               ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################
def currenttopipsandseveritychart(thismonth):
    
    # Original version, trying to open the file
    '''
    try:
        xl=pd.ExcelFile('Shure_External_' + thismonth + '_2022.xlsx')
        restring='.*' + thismonth + '.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        #currentmonthrawdata = pd.read_csv(thismonth + '.csv',  low_memory=False)
        currentmonthrawdata = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
    except:
        print("Data file not foud for this month. Expected to find Shure_External_" + thismonth + '_2022.xlsx', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
    
    '''
    query="SELECT * FROM "+thismonth.lower()+"_"+str(year)
    currentmonthrawdata=pd.read_sql(query, sqladbconn)
    print(currentmonthrawdata)
    #exit()
    # Identifying the top 10 hosts by counting findings
    topips=currentmonthrawdata['IP Address'].value_counts().nlargest(10)
    # Grouping severities to IPs to visualize
    atm=currentmonthrawdata.groupby(['IP Address', 'Severity']).size().unstack()


    #Creating lists to populate with the respective attribute
    #These lists will later be compiled into a dataframe
    #The dataframe will then be used to created stacked bar chart
    ipaddresses=[]
    critical=[]
    high=[]
    low=[]
    none=[]

    #for each ip in the grouped data, compare that to the original CSV
    for ip1 in atm.index:

        for ip2 in topips.index:

            #If IPs match, then it is a top 10 IP
            #we will populate the severity lists
            #so that we can later visualize them
            if ip1==ip2:
                ipaddresses.append(ip1)
                critical.append(atm.loc[ip1, 'Critical'])
                high.append(atm.loc[ip1, 'High'])
                low.append(atm.loc[ip1, 'Low'])
                none.append(atm.loc[ip1, 'None'])

    #Compiling each list into a dictionary
    topaugustipswithseverities={'IP Address':ipaddresses, 'Critical':critical, 'High':high, 'Low':low, 'None':none}
    #converting the dictionary to a dataframe
    augusttop=pd.DataFrame.from_dict(topaugustipswithseverities)
    #print(topips)


    #replacing NaN with 0
    augusttop = augusttop.fillna(0)

    #adding the rows to get a sum to be sorted
    augusttop["total"] = augusttop.sum(axis=1)
    augusttop = augusttop.sort_values(by=['total'], ascending=True)

    #Removing the place holder total column for visualization
    augusttop = augusttop.drop('total', axis=1)

    #defining a horizontal stacked bar chart
    ax=augusttop.plot(kind='barh', stacked=True)
    #assigning IP addresses to the y-axis ticks
    ax.set_yticklabels(ipaddresses)


    # Labeling the chart
    ax.set_title("Top 10 vulnerable IPs based on findings count for " + thismonth, fontsize=12)

 
    ##  This for loop displays and labels the counts for each respective stacked bar  ##
    for i in ax.patches:
        # get_width pulls left or right; get_y pushes up or down
        ax.text(i.get_width()+.1, i.get_y()+.31, \
                str(round((i.get_width()), 2)), fontsize=12, color='dimgrey')

    #Using the X axis label to display the dataframe as a table
    plt.xlabel(augusttop.to_string(index=False, justify=CENTER))

    #Using a logarithmic scale so that everything is easier to see
    plt.xscale("log")


    #making it look nicer
    plt.tight_layout()
    #showing the chart
    plt.show()


    print(currentmonth)



















##############################################################
##                                                          ##
##      This function calculates the top 10 vulnerable      ##
##      hosts by total vulnerabilities found for the input  ##
##      month                                               ##
##                                                          ##
##############################################################

def top10hosts(convertedmonth):
    # Try to open the file
    #inputmonth=convertedmonth + '.csv'
    monthname=convertedmonth
    
    hosts=[]
    
    
    '''
    try:
        # for CSV data sources
        #monthtocount = pd.read_csv(inputmonth,  low_memory=False)
        #For parsing the Excel doc from Pondurance
        xl=pd.ExcelFile('Shure_External_' + convertedmonth + '_2022.xlsx')
        restring='.*' + convertedmonth + '.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        #currentmonthrawdata = pd.read_csv(thismonth + '.csv',  low_memory=False)
        monthtocount = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
    except:
        print("While attempting to calculate top 10 vulnerable hosts for ", convertedmonth,", we expected to find ", inputmonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
    '''
    query="SELECT * FROM "+convertedmonth.lower()+"_"+str(year)
    monthtocount=pd.read_sql(query, sqladbconn)


    for host in monthtocount['IP Address'].value_counts().nlargest(10).index:
        hosts.append(host)
    tophosts={monthname: hosts}
    return tophosts

#print(top10hosts(getmonth(rawmonth-2)))
#print(getmonth(rawmonth))







##############################################################
##                                                          ##   
##      This function identifies and analyzes the top       ##
##      vulnerable hosts YTD that remain vulnerable         ##
##                                                          ##
##      YTD top consistently vulnerable hosts               ##
##############################################################

def consistenhosts():
    #creating temporary dataframes to process and analyze data
    tempdf2=pd.DataFrame()
    tempdf3=pd.DataFrame()
    tempdf4=pd.DataFrame()

    monthforvulncount=[]



    #getting all of the tables for this year
    mycursor.execute("SHOW TABLES LIKE '%"+str(year)+"'")
    #adding the available months to a list for later processing
    for x in mycursor:
        monthforvulncount.append(x[0])
    #counting the number of vulnerabilities from each month
    #and adding it to a list for later processing
    '''
    for monthsytd in monthforvulncount:
        mycursor.execute("SELECT COUNT(*) FROM "+monthsytd)
        tempcount=mycursor.fetchone()
        vulncounts.append(tempcount[0])
    '''
    #monthforvulncount=map(str.strip('2022'), monthforvulncount)
    m2=[]
    for item in monthforvulncount:
        if "_2022" in item:
            m2.append(item.strip("_2022"))
    for i in m2:
        #print(i)
        ##############################################Gets the top top vulnerable IPs for the currently iterated month
        tempdf=pd.DataFrame.from_dict(top10hosts(i))


        #Gets the top 10 vulnerable IPs for THIS month (or last.... as indicated)
        if continuewithold=="y":
            currentdf=pd.DataFrame.from_dict(top10hosts(getmonth(rawmonth-1)))
        else:
            currentdf=pd.DataFrame.from_dict(top10hosts(getmonth(rawmonth)))

        #Compares the top vulnerable IPs in the current iterated month 
        #to the top IPs this month. Any matches found are assigned to the
        #results dataframe
        if continuewithold=="y":
            results= currentdf[currentdf[[getmonth(rawmonth-1)]].astype(str).sum(axis = 1).isin(tempdf[[i]].astype(str).sum(axis = 1))]
        else:
            results= currentdf[currentdf[[getmonth(rawmonth)]].astype(str).sum(axis = 1).isin(tempdf[[i]].astype(str).sum(axis = 1))]

        #Combining the results into "tempdf2" as we iterate through each month ytd
        tempdf2=pd.concat([tempdf2,results])



        #Combining the results into "tempdf2" as we iterate through each month ytd
        tempdf2=pd.concat([tempdf2,results])

        #to make sense of the data and to visualize it, we transpose the data into a
        #new dataframe with appropriately named columns
        tempdf3['ips']=results
        tempdf3['month']=i
        tempdf3['monthnumber']=i###########################################################33 ????????? this i could cause a problem

        #dropping blank rows that were automatically created
        #during the iterative process
        tempdf3=tempdf3[tempdf3['ips'].notna()]

        #combining all the data together so that it can be visualized
        tempdf4=pd.concat([tempdf4,tempdf3])
    #defining the attributes that we want to visualize
    chart=tempdf4.groupby(['ips', 'month']).size().unstack()

    #defining the chart (barh = horizontal bar chart)
    chart.plot(kind='barh', stacked=True)

    #naming and presenting the chart
    plt.title('The below addresses were in the top 10 vulnerable IPs during a previous month YTD, and are still in the top 10 IPs this month. \nThis stacked bar chart indicates which month YTD respective IPs were in the top 10. \nMonths are stacked to indicate how frequently this happens and to help prioritize.')
    plt.show()
    '''
    #Iterates through all months YTD to identify top vulnerable IPs for analysis
    #for i in range(rawmonth + 1):
    for i in range(rawmonth - 1):
        #If the month number is not zero (because january = 1) and is less then the current month number, analyze
        #if i != 0 and i < rawmonth and i != 1:
        if i != 0 and i < rawmonth and i != 1:
            
            #Getting the actual month name to reference from the data for processing
            monthtoprocess=getmonth(i)
            #print(monthtoprocess)
            ##############################################Gets the top top vulnerable IPs for the currently iterated month
            tempdf=pd.DataFrame.from_dict(top10hosts(monthtoprocess))






            #Gets the top 10 vulnerable IPs for THIS month
            currentdf=pd.DataFrame.from_dict(top10hosts(getmonth(rawmonth)))










            #Compares the top vulnerable IPs in the current iterated month 
            #to the top IPs this month. Any matches found are assigned to the
            #results dataframe
            results= currentdf[currentdf[[getmonth(rawmonth)]].astype(str).sum(axis = 1).isin(tempdf[[monthtoprocess]].astype(str).sum(axis = 1))]











            #Combining the results into "tempdf2" as we iterate through each month ytd
            tempdf2=pd.concat([tempdf2,results])

            #to make sense of the data and to visualize it, we transpose the data into a
            #new dataframe with appropriately named columns
            tempdf3['ips']=results
            tempdf3['month']=monthtoprocess
            tempdf3['monthnumber']=i

            #dropping blank rows that were automatically created
            #during the iterative process
            tempdf3=tempdf3[tempdf3['ips'].notna()]

            #combining all the data together so that it can be visualized
            tempdf4=pd.concat([tempdf4,tempdf3])


    #defining the attributes that we want to visualize
    chart=tempdf4.groupby(['ips', 'month']).size().unstack()

    #defining the chart (barh = horizontal bar chart)
    chart.plot(kind='barh', stacked=True)

    #naming and presenting the chart
    plt.title('The below addresses were in the top 10 vulnerable IPs during a previous month YTD, and are still in the top 10 IPs this month. \nThis stacked bar chart indicates which month YTD respective IPs were in the top 10. \nMonths are stacked to indicate how frequently this happens and to help prioritize.')
    plt.show()

'''




##############################################################
##                                                          ##
##      This function counts the total number of            ##
##      vulnerabilities found for the input month           ##
##                                                          ##
##############################################################
def vulncounter(month):
        # Try to open the file
    try:
        xl=pd.ExcelFile('Shure_External_' + month + '_2022.xlsx')
        restring='.*' + month + '.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        #currentmonthrawdata = pd.read_csv(thismonth + '.csv',  low_memory=False)
        monthrawdata = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
        vulncount=len(monthrawdata.index)
    except:
        print("Encountered one or both potential errors:")
        print("Data file not foud for this month. Expected to find Shure_External_" + month + '_2022.xlsx', "in the current working directory (", os.getcwd(), "), but failed.")
        print("A worksheet was not found for " + month + "'s excel file for external vulns")
        proceed=input("Would you like to continue? (y/n)")
        if proceed == 'y':
            vulncount=0
        else:
            exit()
    '''
    try:
        monthrawdata = pd.read_csv(month + '.csv',  low_memory=False)
        vulncount=len(monthrawdata.index)
    except:
        print("Data file not foud for this month. Expected to find ", month + '.csv', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
    '''
    
    return vulncount








##############################################################
##                                                          ##
##      This function aggregates YTD vulnerabilities        ##
##      and presents them on a line chart by month          ##
##                                                          ##
##############################################################
def ytdvulnsbymonth():
    vulncounts=[]
    monthforvulncount=[]
    '''
    for i in range(rawmonth + 1):
        if i != 0:
            vulncounts.append(vulncounter(getmonth(i)))
            monthforvulncount.append(getmonth(i))
    '''
    #getting all of the tables for this year
    mycursor.execute("SHOW TABLES LIKE '%"+str(year)+"'")
    #adding the available months to a list for later processing
    for x in mycursor:
        monthforvulncount.append(x[0])
    #counting the number of vulnerabilities from each month
    #and adding it to a list for later processing
    for monthsytd in monthforvulncount:
        mycursor.execute("SELECT COUNT(*) FROM "+monthsytd)
        tempcount=mycursor.fetchone()
        vulncounts.append(tempcount[0])

    
    #Compiling each list into a dictionary for further processing
    mvtracker={'Month':monthforvulncount, 'Vulnerabilities discovered':vulncounts}


    #converting to dataframe for actual processing
    monthlyvulntracker=pd.DataFrame.from_dict(mvtracker)
    
    #adding a column and assigning month numbers to sort
    monthlyvulntracker['monthnumber']=monthlyvulntracker['Month'].map(lambda x: 1 if "january" in x else 2 if "february" in x else 3 if "march" in x else 4 if "april" in x else 5 if "may" in x else 6 if "june" in x else 7 if "july" in x else 8 if "august" in x else 9 if "september" in x else 10 if "october" in x else 11 if "november" in x else 12 if "december" in x else "")
    #sorting the dataframe
    monthlyvulntracker=monthlyvulntracker.sort_values(by=['monthnumber'], ascending=True)
    #dropping the extra column
    monthlyvulntracker=monthlyvulntracker.drop('monthnumber', axis=1)
    
    
    
    
    
    plt.plot(monthlyvulntracker["Month"], monthlyvulntracker["Vulnerabilities discovered"])



    plt.title("Count of vulnerabilities by month")
    for x, y in zip(monthlyvulntracker["Month"], monthlyvulntracker["Vulnerabilities discovered"]):
        label = y
        plt.annotate(label, (x, y),xycoords="data",textcoords="offset points",xytext=(0, 10), ha="center")
    plt.show()













##############################################################
##                                                          ##
##      This function compares discovered CVEs with         ##
##      CISA's list of CVEs that are known to be            ##
##      Exploited in the wild
##                                                          ##
##############################################################


def exploitedinthewild(month):


# loading the CISA list and assigning the CVE column to a variable that can be searched
    try:
        cisalist = pd.read_csv('https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv', low_memory=False) 
        searchfor = cisalist['cveID']
    except:
        print("Couldn't load the list of known exploited vulnerabilities from CISA! Quitting!")
        exit()
# Try to open the file
    inputmonth=month + '.csv'


    '''

    try:
        xl=pd.ExcelFile('Shure_External_' + month + '_2022.xlsx')
        restring='.*' + month + '.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        #currentmonthrawdata = pd.read_csv(thismonth + '.csv',  low_memory=False)
        wholemonth = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
    except:
        print("Data file not foud for this month. Expected to find Shure_External_" + month + '_2022.xlsx', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
    '''
    '''
    try:
        wholemonth = pd.read_csv(inputmonth,  low_memory=False)
    except:
        print("While attempting to compare vulnerabilities, we expected to find ", inputmonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed. Quitting!")
        exit()
    '''
    query="SELECT * FROM "+month.lower()+"_"+str(year)
    wholemonth=pd.read_sql(query, sqladbconn)
# dropping machines without a CVE from the table so the data can be parsed
    wholemonth.dropna(subset=['CVE'], inplace=True)
#############################################
# comparing the list of known exploitable CVEs to the
# list available from Pondurance and assigning it
# to another variable for further processing
##############################################

    results = wholemonth[wholemonth['CVE'].str.contains('|'.join(searchfor))]


    allcvecount=len(wholemonth.index)
    resultscount = len(results.index)
    #print("Total CVE's foud in our environment: ", allcvecount)
    #print("Of these, count of CVEs known to be exploited: ", resultscount)
    #print(results[['IP Address','CVE']])
    #return vulncount

    sources=['Total Discovered CVEs: ' + str(allcvecount), 'CVEs identified by CISA as being actively exploited: ' + str(resultscount)]
    data=[allcvecount,resultscount]
    plt.pie(data, labels=sources, autopct='%1.1f%%')
    plt.title('Actively exploited CVEs found in our environment for ' + month)
    #plt.text(-3.1, 0.1, 'Sine wave', fontsize = 23)
    plt.text(2.1, 1, 'List of CVEs found in our environment\nknown to be actively exploited in the wild:\n\n' + results[['IP Address','CVE']].to_string(index=False, justify=CENTER), fontsize = 12)
    #print(results[['IP Address','CVE']].to_string(index=False, justify=CENTER))
    plt.show()

























################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function takes the current top 10 IPs and      ##              ####
####            ##      creates a table and populates it with the top 10    ##              ####
####            ##      IPs along its respective hostname, internal IP, OS  ##              ####
####            ##      protocol(s), port(s), and service name(s)           ##              ####
####            ##                                                          ##              ####
####            ##      Inventory.csv is the list of external hosts along   ##              ####
####            ##      with their respective host names and internal IPs   ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################

def inventorytable():

    
    query="SELECT * FROM external_resource_inventory"
    inventory=pd.read_sql(query, sqladbconn)
    '''
    try:
        inventory = pd.read_csv('inventory.csv',  low_memory=False) 
    except:
        print("inventory file not foud for this month. Expected to find inventory.csv in the current working directory (", os.getcwd(), "), but failed.")
        exit()
    '''
    #Gets the name of the current month, passes it to the top 10 hosts function, which
    #returns the current top 10 in the form of a dictionary. Then, a pandas dataframe
    #is created from that dictionary


    if continuewithold=="y":
        currenttop10=pd.DataFrame.from_dict(top10hosts(getmonth(rawmonth-1)))
    else:
        currenttop10=pd.DataFrame.from_dict(top10hosts(getmonth(rawmonth)))

    
    
    
    finaltable=inventory[inventory['IP Address'].str.contains('|'.join(currenttop10.iloc[:,0]))]
    #print(currenttop10.iloc[:,0].values)
    #searchfor = cisalist['cveID']
    
    #results = wholemonth[wholemonth['CVE'].str.contains('|'.join(searchfor))]
    #print(currenttop10)
    #def listingtop10():
    #    for ip1 in currenttop10.iloc[:,0]:
    #        return ip1
    #for ip2 in inventory['IP Address']:
    finaltable.fillna('Unkown', inplace=True)
    #print(finaltable)   
        


    #preparing a table to present the data
    fig, ax = plt.subplots()
    # hide axes
    fig.patch.set_visible(False)
    ax.axis('off')
    ax.axis('tight')
    #assigning data to the matplotlib table
    #tb =ax.table(cellText=finaltable.values, colLabels=finaltable.columns,loc='center')
    
    #ax.table(cellText=finaltable.values, colLabels=finaltable.columns,loc='center')
    
    #tb.set_fontsize(100)
    
    #plt.text(-0.1, 0, finaltable.to_string(index=False, justify=CENTER), fontsize = 8)
    plt.text(-0.125, 0, '  A CSV file named "top 10 ips with attributes.csv" has been saved to the local working directory this script was executed from.\n\n It contains the top 10 most vulnerable IPs found this month along with (where the respective information is available) their \n\n hostname, internal IP, OS, effected protocol, effected port, and service name. \n\n Additional rows exist for each IP to breaking them down via these attributes where appropriate.', fontsize = 12)
    #plt.title('font', size=2)
    #fig.set_size_inches(500,500, forward=True)
    fig.tight_layout()
    plt.show()
    finaltable.to_csv(r'top 10 ips with attributes.csv', index = False)
    #print(finaltable)



################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function launches the input file               ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################
def filelauncher():
    if platform.system() == 'Darwin':       # macOS
        subprocess.call(('open', filepath))
    elif platform.system() == 'Windows':    # Windows
        os.startfile(filepath)
    else:                                   # linux variants
        subprocess.call(('xdg-open', filepath))

################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function creates a powerpoint presentation     ##              ####
####            ##      to present our analyses and visualizations          ##              ####
####            ##                                                          ##              ####
####            ##                                                          ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################
#lll
#prs=Presentation()
#lyt=prs.slide_layouts[0] # choosing a slide layout
#slide=prs.slides.add_slide(lyt) # adding a slide
#title=slide.shapes.title # assigning a title
#subtitle=slide.placeholders[1] # placeholder for subtitle
#title.text="Hey,This is a Slide! How exciting!" # title
#subtitle.text="Really?" # subtitle
#prs.save("slide1.pptx") # saving file
#########################################################################



################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function tracks vulnerability remediations     ##              ####
####            ##      by comparing current and previous vulnerability     ##              ####
####            ##      "titles" for each IP in the scan results            ##              ####
####            ##                                                          ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################




def remediations(month,lmonth):


# Try to open the file
    thismonthfile=month + '.csv'
    lastmonthfile=lmonth + '.csv'

    try:
        thismonthdf = pd.read_csv(thismonthfile,  low_memory=False)
    except:
        print("While attempting to load this months data to analyze remediations, we expected to find ", thismonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed. Quitting!")
        exit()

    try:
        lastmonthdf = pd.read_csv(lastmonthfile,  low_memory=False)
    except:
        print("While attempting to load this months data to analyze remediations, we expected to find ", thismonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed. Quitting!")
        exit()

    #Combining IPs with vulnerability titles into one column for easy comparison
    lastmonthdf['combined']=lastmonthdf['IP Address'] + lastmonthdf['Title']
    thismonthdf['combined']=thismonthdf['IP Address'] + thismonthdf['Title']


    #searching for vulnerabilities that have not been remediated since at least last month's scan. 
    #By using the concatenated (combined columns) data of IP Address and Title, this is being determined
    #by looking at this months and last months data; where an IP Address and Title match between both
    #datasets, it is logically assumed that the vulnerability has not been remediated and persists. 


    rresults=thismonthdf[thismonthdf['combined'].str.contains('|'.join(lastmonthdf['combined']))]
    #Searching for vulnerabilities that have been remediated. This is determined by performing 
    #the opposite query as above. In other words, we're searching this months IP addresses and titles
    #and returning all rows that do NOT match last months data. In this way, we are logically assuming 
    #that a vulnerability has been remediated. Please note that this ONLY considers vulnerability scan results
    #and certain other factors (like a server getting decommissioned) could effect the results. In the future
    #it may be possible to check server status with a ping to reconcile this potential discrepancy.
    dresults=thismonthdf[~thismonthdf['combined'].str.contains('|'.join(lastmonthdf['combined']))]
    #totaldifferancecount = thismonthdf[thismonthdf['IP Address'].str.contains('|'.join(lastmonthsips))]
    print(rresults['combined'])
    print(dresults['combined'])

###############concatenate these two rows and compare that way??
    #print(results['combined'])
    #overallchange=len(lastmonthsips.index)-len(results.index)
    #print(len(results.index))
    #print(len(lastmonthsips.index))
    #print('There was an overall difference overallchange)

#remediations(getmonth(rawmonth),getmonth(rawmonth-1))












################################################################################################
####                                                                                        ####
####            ##############################################################              ####
####            ##                                                          ##              ####
####            ##      This function searches all discovered CVEs for      ##              ####
####            ##      matches in Offsec's exploitDB, reporting on the     ##              ####
####            ##      results.                                            ##              ####
####            ##                                                          ##              ####
####            ##############################################################              ####
####                                                                                        ####
################################################################################################

def exploitsearch(month):

    #Creating a list to store found exploits in
    availableexploits=[]
    query="SELECT * FROM "+month.lower()+"_"+str(year)
    monthtocount=pd.read_sql(query, sqladbconn)
    #isolating the CVE column for processing
    tempcvelist = monthtocount['CVE']
    #converting the created series to a dataframe to be cleaned up
    cvelist=pd.DataFrame(tempcvelist, columns=['CVE'])
    #dropping rows with no CVE
    cvelist=cvelist.dropna()
    #dropping duplicate CVE entries
    cvelist=cvelist.drop_duplicates()
    #converting to a list for easy iteration later on
    cvelist=cvelist['CVE'].tolist()
    '''
    try:
        #loading in the scan report 
        xl=pd.ExcelFile('Shure_External_September_2022.xlsx')
        restring='.*September.*External\sVulns'
        regex=re.compile(restring)
        sheets=[n for n in xl.sheet_names if regex.match(n)]
        truesheet="".join(sheets)
        monthtocount = pd.read_excel (xl, sheet_name=truesheet, skiprows=1)
        #isolating the CVE column for processing
        tempcvelist = monthtocount['CVE']
        #converting the created series to a dataframe to be cleaned up
        cvelist=pd.DataFrame(tempcvelist, columns=['CVE'])
        #dropping rows with no CVE
        cvelist=cvelist.dropna()
        #dropping duplicate CVE entries
        cvelist=cvelist.drop_duplicates()
        #converting to a list for easy iteration later on
        cvelist=cvelist['CVE'].tolist()
    except:
        print("While attempting to calculate top 10 vulnerable hosts for ", convertedmonth,", we expected to find ", inputmonth + '.csv', "in the current working directory (", os.getcwd(), "), but failed.")
        exit()
        '''

    gcolumns=list(monthtocount)
    exploitablemachines=pd.DataFrame(columns=gcolumns)

    #iterating through each discovered CVE to search for exploits
    for cve in cvelist:

        print("\n\n\n")
        pEdb = PyExploitDb() 
        pEdb.debug = False 
        pEdb.openFile() 
        results = pEdb.searchCve(cve) 

        if not results:
            print("No exploit found")
        else:
            #add the found exploit to a list
            availableexploits.append(cve)
            #when an exploit is found, adding the full row from the scan report for context
            df1=monthtocount[monthtocount["CVE"].str.contains(cve, na=False)]
            #Combining this iteration's results with all results
            exploitablemachines=pd.concat([exploitablemachines, df1])
            availableexploits.append(cve)

    availableexploits=list(dict.fromkeys(availableexploits))
    print("\n\n\n")
    print("For "+month+", these CVEs were discovered in our environment with an available exploit:")

    print(availableexploits)
    print("\nThe below table is a preview of the complete discovery of machines with easily available exploits.")
    print("exploitablemachines.csv has been saved to the current working directory for review\n")
    exploitablemachines.to_csv(r'exploitablemachines.csv', index = False)
    return exploitablemachines










        ### ##############################################################  ###
    ###     ##                                                          ##      ###
###         ##      Let's get to work and process our functions!        ##          ###
    ###     ##                                                          ##      ###
        ### ##############################################################  ###

##  Current month top 10 IPs by severity
#'''
if continuewithold=="y":
    currenttopipsandseveritychart(getmonth.getmonth(rawmonth-1))
else:
    currenttopipsandseveritychart(getmonth.getmonth(rawmonth))
#'''
##  YTD vulns by month
#ytdvulnsbymonth()


##  Find which CVES have been observed to be actively exploited
'''
if continuewithold=="y":
    exploitedinthewild(getmonth(rawmonth-1))
else:
    exploitedinthewild(getmonth(rawmonth))
'''

## Identifies hosts that are consistently vulnerable that remain vulnerable this month
#consistenhosts()

## Exports a CSV of the top 10 IPs this month with additional attributes
#inventorytable()

##  Searches CVES from the scan for available exploits
'''
if continuewithold=="y":
    print(exploitsearch(getmonth(rawmonth-1)))
else:
    print(exploitsearch())
'''